<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Clash Online - å®Œæ•´ç‰ˆ</title>
<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<style>
/* --- 1. å…¨åŸŸè®Šæ•¸ --- */
:root {
    --primary: #3498db; --accent: #f1c40f; --danger: #e74c3c; --success: #2ecc71;
    --dark-bg: #1e272e; --ui-glass: rgba(30, 39, 46, 0.95);
    --font-main: "PingFang TC", "Microsoft JhengHei", system-ui, sans-serif;
    --common: #bdc3c7; --rare: #f39c12; --epic: #9b59b6; --legendary: #00cec9;
    --gold: #ffd700; --gem: #2ecc71;
}

body {
    margin: 0; padding: 0; background-color: #000; color: white;
    font-family: var(--font-main); overflow: hidden; width: 100%; height: 100%;
    user-select: none; touch-action: none; position: fixed;
}

/* =========================================
   éŠæˆ²å±¤ (GAME VIEW)
   ========================================= */
#game-container { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    display: none; flex-direction: column; z-index: 1; 
}
#game-container.active { display: flex; }

#canvas-wrapper { position: relative; flex: 1; width: 100%; background: #2c3e50; overflow: hidden; box-shadow: inset 0 -20px 50px rgba(0,0,0,0.5); }
canvas { display: block; width: 100%; height: 100%; }

/* æˆ°é¬¥ UI */
#ui-layer {
    height: 160px; background: var(--ui-glass); backdrop-filter: blur(15px);
    border-top: 1px solid rgba(255,255,255,0.15); display: flex; flex-direction: column;
    padding: 5px 10px 10px 10px; box-sizing: border-box; z-index: 20; position: relative;
}

/* è–æ°´æ¢ */
#elixir-area { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; padding: 0 5px; height: 30px; }
#elixir-badge { width: 30px; height: 30px; background: linear-gradient(135deg, #a55eea, #8854d0); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 900; font-size: 16px; box-shadow: 0 0 15px rgba(165, 94, 234, 0.6); border: 2px solid #fff; z-index: 2; }
#elixir-bar-bg { flex: 1; height: 12px; background: rgba(0,0,0,0.8); border-radius: 10px; overflow: hidden; position: relative; border: 2px solid #57606f; }
#elixir-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #a55eea, #d980fa); box-shadow: 0 0 20px #a55eea; transition: width 0.1s linear; }

/* æ‰‹ç‰Œå€ */
#deck-area { display: flex; align-items: flex-end; gap: 8px; height: 100%; flex: 1; width: 100%; }
#next-slot { display: flex; flex-direction: column; align-items: center; opacity: 0.7; margin-right: 4px; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 4px; width: 45px; flex-shrink: 0; }
.slot-label { font-size: 9px; color: #aaa; font-weight: 800; margin-bottom: 2px; }
#hand-cards { display: flex; gap: 6px; justify-content: space-between; flex: 1; height: 100%; }

/* å¡ç‰Œæ¨£å¼ */
.card {
    flex: 1; max-width: 85px; height: 90%;
    background: linear-gradient(160deg, #3d4c53, #2c3e50);
    border-radius: 10px; position: relative; cursor: pointer;
    transition: transform 0.1s; border: 2px solid #57606f;
    box-shadow: 0 4px 0 rgba(0,0,0,0.3); overflow: hidden; user-select: none;
}
.card.common { border-color: var(--common); } .card.rare { border-color: var(--rare); } .card.epic { border-color: var(--epic); } .card.legendary { border-color: var(--legendary); }
.card-inner { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding-top: 10px; background: radial-gradient(circle at center, rgba(255,255,255,0.1) 0%, transparent 70%); }
.card.selected { transform: translateY(-12px); border-width: 3px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.4); background: linear-gradient(160deg, #576574, #3d4c53); z-index: 10; }
.card.disabled { filter: grayscale(1) brightness(0.5); pointer-events: none; transform: none; }
.cost { position: absolute; top: -1px; left: -1px; width: 20px; height: 20px; background: #fff; color: #8854d0; border-bottom-right-radius: 10px; font-weight: 900; font-size: 12px; display: flex; align-items: center; justify-content: center; box-shadow: 1px 1px 3px rgba(0,0,0,0.3); z-index: 2; border: 2px solid #8854d0; }
.emoji { font-size: 28px; filter: drop-shadow(0 3px 2px rgba(0,0,0,0.3)); margin-bottom: 2px; }

/* HUD Top */
#hud-top { position: absolute; top: 0; left: 0; width: 100%; padding: 10px 15px; box-sizing: border-box; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 15; }
#timer-box { background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); margin: 0 auto; }
#timer { font-size: 24px; font-weight: 900; color: #fff; font-variant-numeric: tabular-nums; }
#enemy-info {
    position: absolute; top: 15px; left: 15px;
    background: rgba(231, 76, 60, 0.8); padding: 6px 14px;
    border-radius: 12px; border: 2px solid #fff;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    color: white; font-weight: bold; font-size: 16px;
    text-shadow: 0 2px 2px rgba(0,0,0,0.5); pointer-events: auto;
    display: flex; align-items: center; gap: 5px;
}

#message { position: absolute; top: 30%; width: 100%; text-align: center; font-size: 48px; font-weight: 900; color: var(--accent); -webkit-text-stroke: 2px #000; text-shadow: 0 4px 15px rgba(0,0,0,0.6); pointer-events: none; opacity: 0; transition: all 0.3s; transform: scale(0.5); z-index: 50; }
#message.show { opacity: 1; transform: scale(1); }
#elixir-mode-txt { position: absolute; top: 20%; width: 100%; text-align: center; font-size: 32px; font-weight: 900; color: #e84393; text-shadow: 0 0 10px #fff, 0 0 20px #e84393; pointer-events: none; opacity: 0; transform: scale(1.5); transition: all 0.5s; z-index: 45; }
#elixir-mode-txt.show { opacity: 1; transform: scale(1); }

#emote-wrapper { position: absolute; bottom: 170px; left: 15px; z-index: 30; display: flex; flex-direction: column-reverse; gap: 10px; }
#emote-btn { width: 44px; height: 44px; background: rgba(0,0,0,0.6); border: 2px solid #fff; border-radius: 50%; font-size: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
#emote-menu { background: rgba(0,0,0,0.8); border-radius: 12px; padding: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; opacity: 0; pointer-events: none; transform: scale(0.8) translateY(20px); transition: all 0.2s ease-out; }
#emote-menu.open { opacity: 1; pointer-events: auto; transform: scale(1) translateY(0); }
.emote-opt { font-size: 28px; cursor: pointer; }

/* =========================================
   å¤§å»³å±¤ (LOBBY VIEW)
   ========================================= */
#lobby-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: linear-gradient(135deg, #130f40, #30336b);
    z-index: 100; display: flex; flex-direction: column;
}
.hidden { display: none !important; }

#top-bar {
    height: 60px; background: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: space-between; padding: 0 15px;
    border-bottom: 1px solid rgba(255,255,255,0.1); box-sizing: border-box;
}
.res-group { display: flex; gap: 15px; }
.res-item { display: flex; align-items: center; gap: 5px; font-weight: bold; font-size: 14px; background: rgba(0,0,0,0.5); padding: 4px 10px; border-radius: 15px; }
.icon-gold { color: var(--gold); } .icon-gem { color: var(--gem); } .icon-trophy { color: var(--accent); }

#tab-content { flex: 1; overflow-y: auto; padding: 20px; padding-bottom: 80px; position: relative; box-sizing: border-box; }
.tab-pane { display: none; animation: fadeIn 0.3s; height: 100%; width: 100%; }
.tab-pane.active { display: flex; flex-direction: column; align-items: center; }

#nav-bar {
    height: 70px; background: #1e272e; border-top: 1px solid rgba(255,255,255,0.1);
    display: flex; justify-content: space-around; align-items: center;
    position: absolute; bottom: 0; width: 100%; z-index: 101;
}
.nav-btn {
    background: none; border: none; color: #7f8c8d; font-size: 10px;
    display: flex; flex-direction: column; align-items: center; gap: 4px;
    cursor: pointer; width: 25%; transition: 0.2s;
}
.nav-btn i { font-size: 24px; font-style: normal; }
.nav-btn.active { color: #fff; transform: translateY(-5px); }
.nav-btn.active i { color: var(--primary); text-shadow: 0 0 10px var(--primary); }

.hero-banner { text-align: center; margin-top: 20px; margin-bottom: 30px; }
.rank-badge { width: 100px; height: 100px; background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path fill="%23f1c40f" d="M50 2 L90 25 L90 75 L50 98 L10 75 L10 25 Z"/></svg>') no-repeat center; background-size: contain; display: flex; align-items: center; justify-content: center; margin: 0 auto; font-size: 40px; filter: drop-shadow(0 0 10px rgba(241, 196, 15, 0.5)); }
.arena-name { font-size: 24px; font-weight: bold; color: #fff; margin-top: 10px; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
.chest-slots { display: flex; gap: 10px; width: 100%; justify-content: center; margin-bottom: 30px; }
.chest { width: 70px; height: 70px; background: #57606f; border-radius: 10px; border: 2px dashed #7f8c8d; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #a4b0be; flex-direction: column; cursor: pointer; text-align: center; }
.chest.has-loot { background: linear-gradient(135deg, #6c5ce7, #a55eea); border: 2px solid #fff; color: #fff; border-style: solid; animation: pulse 2s infinite; }

.btn-battle {
    background: linear-gradient(180deg, #f1c40f, #e67e22); border: none; border-radius: 12px;
    padding: 15px 60px; font-size: 28px; font-weight: 900; color: #fff;
    box-shadow: 0 6px 0 #d35400, 0 15px 20px rgba(0,0,0,0.4); cursor: pointer;
    text-transform: uppercase; letter-spacing: 2px; transition: 0.1s; margin-bottom: 20px;
}
.btn-battle:active { transform: translateY(6px); box-shadow: 0 0 0 #d35400; }
.btn-battle:disabled { filter: grayscale(1); transform: translateY(6px); box-shadow: 0 0 0 #555; cursor: not-allowed; }

.deck-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; width: 100%; max-width: 500px; box-sizing: border-box; }
.deck-card {
    aspect-ratio: 3/4; background: #34495e; border-radius: 8px; position: relative; border: 2px solid transparent; cursor: pointer;
}
.deck-card.equipped { border-color: #2ecc71; box-shadow: 0 0 10px rgba(46, 204, 113, 0.3); }
.deck-card .lv-badge { position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); background: #000; padding: 1px 6px; font-size: 10px; border-radius: 4px; color: #fff; white-space: nowrap; }
.deck-card .upgrade-arrow { position: absolute; top: -5px; right: -5px; background: #2ecc71; color: #fff; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); animation: bounce 1s infinite; }
.upgrade-panel { background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; margin-top: 15px; width: 100%; text-align: center; display: none; box-sizing: border-box; }
.upgrade-panel.active { display: block; }
.progress-bar { width: 100%; height: 6px; background: #000; border-radius: 3px; margin: 5px 0; overflow: hidden; }
.progress-fill { height: 100%; background: #2ecc71; width: 50%; }

.social-header { display: flex; gap: 10px; width: 100%; margin-bottom: 20px; }
.tab-pill { flex: 1; background: rgba(255,255,255,0.1); padding: 10px; text-align: center; border-radius: 8px; cursor: pointer; }
.tab-pill.active { background: var(--primary); font-weight: bold; }
.friend-list, .clan-view { width: 100%; display: flex; flex-direction: column; gap: 10px; }
.social-item { background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; }
.status-dot { width: 10px; height: 10px; border-radius: 50%; background: #95a5a6; display: inline-block; margin-right: 5px; }
.status-dot.online { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
.btn-mini { padding: 6px 12px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; font-size: 12px; }
.btn-invite { background: #3498db; color: white; }
.btn-spectate { background: #9b59b6; color: white; }

#end-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; backdrop-filter: blur(5px); }
#end-screen.active { display: flex; }

@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
@keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
@keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(165, 94, 234, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(165, 94, 234, 0); } 100% { box-shadow: 0 0 0 0 rgba(165, 94, 234, 0); } }
</style>
</head>
<body>

<!-- å¤§å»³ (Lobby) -->
<div id="lobby-layer">
    <!-- é ‚éƒ¨è³‡æº -->
    <div id="top-bar">
        <div class="res-group">
            <div class="res-item"><span class="icon-gold">ğŸ’°</span> <span id="ui-gold">0</span></div>
            <div class="res-item"><span class="icon-gem">ğŸ’</span> <span id="ui-gem">0</span></div>
        </div>
        <div class="res-item"><span class="icon-trophy">ğŸ†</span> <span id="ui-trophy">0</span></div>
    </div>

    <!-- åˆ†é å…§å®¹ -->
    <div id="tab-content">
        <!-- Battle Tab -->
        <div id="tab-battle" class="tab-pane active">
            <div class="hero-banner">
                <div class="rank-badge" id="rank-icon">ğŸ›¡ï¸</div>
                <div class="arena-name" id="arena-name">è¨“ç·´ç‡Ÿ</div>
                <div style="color:#aaa; font-size:12px; margin-top:5px;">è³½å­£å‰©é¤˜ 12 å¤©</div>
            </div>
            <div class="chest-slots">
                <div class="chest has-loot" onclick="Lobby.openChest(this)"><div>ğŸ“¦</div>éŠ€å¯¶ç®±<br><span style="font-size:10px">3h</span></div>
                <div class="chest">ç©ºä½</div>
                <div class="chest">ç©ºä½</div>
                <div class="chest">ç©ºä½</div>
            </div>
            <button id="btn-find-match" class="btn-battle" onclick="Lobby.findMatch()">é–‹å§‹å°æˆ°</button>
            
            <!-- Daily Quest -->
            <div style="width:100%; background:rgba(0,0,0,0.2); padding:10px; border-radius:10px; margin-top:10px; box-sizing: border-box;">
                <div style="font-size:14px; font-weight:bold; margin-bottom:5px; display:flex; justify-content:space-between;">
                    <span>ğŸ“œ æ¯æ—¥ä»»å‹™</span> <span style="color:var(--success)">1/3</span>
                </div>
                <div style="font-size:12px; color:#ccc;">ä½¿ç”¨ 10 æ¬¡ç«çƒè¡“ (5/10)</div>
                <div class="progress-bar" style="background:#444;"><div class="progress-fill" style="width:50%; background:var(--accent);"></div></div>
            </div>
        </div>

        <!-- Deck Tab -->
        <div id="tab-deck" class="tab-pane">
            <h2 style="margin:0 0 10px 0;">æˆ°é¬¥ç‰Œçµ„</h2>
            <div class="deck-grid" id="deck-grid"></div>
            
            <div id="upgrade-panel" class="upgrade-panel">
                <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                    <div style="font-size:30px;" id="upg-icon"></div>
                    <div style="text-align:left;">
                        <div style="font-weight:bold;" id="upg-name"></div>
                        <div style="font-size:12px; color:#aaa;" id="upg-level">Lv.1</div>
                    </div>
                </div>
                <div style="display:flex; justify-content:space-between; font-size:12px; margin-bottom:2px;">
                    <span>ç¢ç‰‡æ”¶é›†</span> <span id="upg-count">0/10</span>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="upg-bar"></div></div>
                <button id="btn-upgrade" class="btn-battle" style="font-size:16px; padding:10px; width:100%; margin-top:10px;" onclick="Lobby.upgradeCard()">
                    å‡ç´š <span id="upg-cost">ğŸ’° 50</span>
                </button>
            </div>
        </div>

        <!-- Social Tab -->
        <div id="tab-social" class="tab-pane">
            <div class="social-header">
                <div class="tab-pill active" onclick="Lobby.switchSocial('friends')">å¥½å‹</div>
                <div class="tab-pill" onclick="Lobby.switchSocial('clan')">éƒ¨è½</div>
            </div>
            <div id="view-friends" class="friend-list">
                <div class="social-item">
                    <div style="display:flex; align-items:center;">
                        <div class="status-dot online"></div>
                        <div><div>ç‹è€…é˜¿æ˜</div><div style="font-size:10px; color:#aaa;">ğŸ† 1250</div></div>
                    </div>
                    <div style="display:flex; gap:5px;"><button class="btn-mini btn-spectate">è§€æˆ°</button><button class="btn-mini btn-invite">å‹èª¼æˆ°</button></div>
                </div>
                <div class="social-item">
                    <div style="display:flex; align-items:center;">
                        <div class="status-dot"></div>
                        <div><div>å¤œç…</div><div style="font-size:10px; color:#aaa;">é›¢ç·š 2h</div></div>
                    </div>
                </div>
                <button class="social-item" style="justify-content:center; color:var(--accent); border:1px dashed #aaa; cursor:pointer;">+ æ–°å¢å¥½å‹</button>
            </div>
            <div id="view-clan" class="clan-view hidden">
                <div style="text-align:center; padding:20px; background:rgba(0,0,0,0.2); border-radius:10px;">
                    <div style="font-size:40px;">ğŸ›¡ï¸</div><h2>çš‡å®¶è­·è¡›éšŠ</h2>
                    <p style="color:#aaa; font-size:12px;">æ­¡è¿æ´»èºç©å®¶åŠ å…¥ï¼æ¯é€±æå¡ï¼</p>
                    <button class="btn-mini btn-invite" style="font-size:14px; padding:8px 20px;">é€²å…¥èŠå¤©å®¤</button>
                </div>
                <h3 style="margin:10px 0;">å¡ç‰Œè«‹æ±‚</h3>
                <div class="social-item">
                    <div><div style="font-size:12px;"><b>å°èƒ–</b> è«‹æ±‚æ”¯æ´</div><div style="display:flex; align-items:center; gap:5px;"><span>ğŸ— é‡è±¬é¨å£«</span><span style="font-size:10px; color:#aaa;">(2/4)</span></div></div>
                    <button class="btn-mini btn-invite" onclick="alert('æè´ˆæˆåŠŸï¼ç²å¾— 50 é‡‘å¹£')">æè´ˆ</button>
                </div>
            </div>
        </div>

        <!-- Shop Tab -->
        <div id="tab-shop" class="tab-pane">
            <h2>æ¯æ—¥ç²¾é¸</h2>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div style="background:#fff; color:#000; padding:10px; border-radius:8px; text-align:center;">
                    <div style="font-size:30px;">ğŸ¹</div><div>å¼“ç®­æ‰‹ x10</div><button class="btn-mini btn-invite" style="margin-top:5px;">ğŸ’° 100</button>
                </div>
                <div style="background:#fff; color:#000; padding:10px; border-radius:8px; text-align:center;">
                    <div style="font-size:30px;">ğŸ’</div><div>ä¸€è¢‹å¯¶çŸ³</div><button class="btn-mini btn-spectate" style="margin-top:5px;">$0.99</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Nav -->
    <div id="nav-bar">
        <button class="nav-btn active" onclick="Lobby.switchTab('battle', this)"><i>âš”ï¸</i>æˆ°é¬¥</button>
        <button class="nav-btn" onclick="Lobby.switchTab('deck', this)"><i>ğŸƒ</i>ç‰Œçµ„</button>
        <button class="nav-btn" onclick="Lobby.switchTab('shop', this)"><i>ğŸª</i>å•†åº—</button>
        <button class="nav-btn" onclick="Lobby.switchTab('social', this)"><i>ğŸ‘¥</i>ç¤¾äº¤</button>
    </div>
</div>

<!-- éŠæˆ²å±¤ -->
<div id="game-container">
    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="hud-top">
            <div id="enemy-info">âš”ï¸ <span id="enemy-name-txt">å°æ‰‹</span></div>
            <div id="timer-box"><div id="timer">03:00</div></div>
        </div>
        <div id="emote-wrapper">
            <div id="emote-menu">
                <div class="emote-opt" onclick="Game.triggerEmote('ğŸ˜‚')">ğŸ˜‚</div>
                <div class="emote-opt" onclick="Game.triggerEmote('ğŸ˜¡')">ğŸ˜¡</div>
                <div class="emote-opt" onclick="Game.triggerEmote('ğŸ˜­')">ğŸ˜­</div>
                <div class="emote-opt" onclick="Game.triggerEmote('ğŸ‘')">ğŸ‘</div>
            </div>
            <div id="emote-btn" onclick="document.getElementById('emote-menu').classList.toggle('open')">ğŸ’¬</div>
        </div>
        <div id="elixir-mode-txt">é›™å€è–æ°´æ™‚åˆ»!</div>
        <div id="message"></div>
    </div>
    <div id="ui-layer">
        <div id="elixir-area">
            <div id="elixir-badge">5</div>
            <div id="elixir-bar-bg"><div id="elixir-fill"></div></div>
        </div>
        <div id="deck-area">
            <div id="next-slot">
                <span class="slot-label">ä¸‹å¼µ</span>
                <div class="card" style="height: 60px; width: 100%; max-width: 50px; cursor: default; pointer-events: none;">
                    <div class="card-inner" style="padding-top: 5px;">
                        <div class="emoji" id="next-icon" style="font-size: 20px;">?</div>
                    </div>
                </div>
            </div>
            <div id="hand-cards"></div>
        </div>
    </div>
    <!-- çµç®—ç•«é¢ -->
    <div id="end-screen">
        <h1 id="end-title" style="font-size:60px; margin:0;">å‹åˆ©</h1>
        <div style="font-size:20px; margin-bottom:20px; display:flex; align-items:center; gap:10px;">
            <span id="end-trophy-change" style="color:var(--accent)">+30 ğŸ†</span>
            <span style="color:var(--gold)">+50 ğŸ’°</span>
        </div>
        <button class="btn-battle" onclick="location.reload()">è¿”å›å¤§å»³</button>
    </div>
</div>

<script>
const CONFIG = {
    ELIXIR_RATE_BASE: 0.018, ELIXIR_MAX: 10, GAME_TIME: 180, DOUBLE_ELIXIR_THRESHOLD: 60,
    RIVER_OFFSET: 0.5, BRIDGE_WIDTH: 60,
    COLORS: { P_MAIN: '#3498db', E_MAIN: '#e74c3c', GRASS: '#27ae60', WATER: '#48dbfb' }
};

// å®Œæ•´çš„å¡ç‰Œè³‡æ–™ï¼ŒåŒ…å«è¦–è¦ºåƒæ•¸
const CARDS = {
    knight: { id: 'knight', name: 'é¨å£«', cost: 3, count: 1, hp: 1400, dmg: 130, speed: 0.6, range: 0, atkSpd: 65, type: 'ground', target: 'any', icon: 'âš”ï¸', radius: 16, mass: 6.0, deployTime: 60, rarity: 'common' },
    archer: { id: 'archer', name: 'å¼“ç®­æ‰‹', cost: 3, count: 2, hp: 350, dmg: 80, speed: 0.7, range: 110, atkSpd: 50, type: 'ground', target: 'any', icon: 'ğŸ¹', radius: 12, mass: 1.5, deployTime: 60, rarity: 'common' },
    musketeer: { id: 'musketeer', name: 'ç«æ§æ‰‹', cost: 4, count: 1, hp: 600, dmg: 180, speed: 0.6, range: 140, atkSpd: 60, type: 'ground', target: 'any', icon: 'ğŸ‘’', radius: 14, mass: 2.0, deployTime: 60, rarity: 'rare' },
    giant: { id: 'giant', name: 'å·¨äºº', cost: 5, count: 1, hp: 3500, dmg: 250, speed: 0.4, range: 0, atkSpd: 120, type: 'ground', target: 'building', icon: 'ğŸ¦', radius: 28, mass: 30.0, deployTime: 120, rarity: 'rare' },
    prince: { id: 'prince', name: 'ç‹å­', cost: 5, count: 1, hp: 1600, dmg: 325, speed: 0.7, range: 0, atkSpd: 80, type: 'ground', target: 'any', icon: 'ğŸ', radius: 18, mass: 8.0, deployTime: 60, chargeSpeed: 1.5, chargeDmgMult: 2.0, rarity: 'epic' },
    skarmy: { id: 'skarmy', name: 'éª·é«è»åœ˜', cost: 3, count: 10, hp: 60, dmg: 40, speed: 1.0, range: 0, atkSpd: 30, type: 'ground', target: 'any', icon: 'ğŸ’€', radius: 8, mass: 0.5, deployTime: 30, rarity: 'epic' },
    bats: { id: 'bats', name: 'è™è ', cost: 2, count: 4, hp: 50, dmg: 50, speed: 1.1, range: 0, atkSpd: 25, type: 'air', target: 'any', icon: 'ğŸ¦‡', radius: 8, mass: 0.5, deployTime: 30, rarity: 'common' },
    minipekka: { id: 'minipekka', name: 'è¿·ä½ çš®å¡', cost: 4, count: 1, hp: 1100, dmg: 550, speed: 1.0, range: 0, atkSpd: 95, type: 'ground', target: 'any', icon: 'ğŸ¤–', radius: 16, mass: 5.0, deployTime: 60, rarity: 'rare' },
    hogrider: { id: 'hogrider', name: 'é‡è±¬é¨å£«', cost: 4, count: 1, hp: 1400, dmg: 260, speed: 1.4, range: 0, atkSpd: 70, type: 'ground', target: 'building', icon: 'ğŸ·', radius: 18, mass: 5.0, deployTime: 60, rarity: 'rare' },
    babydragon: { id: 'babydragon', name: 'é£›é¾å¯¶å¯¶', cost: 4, count: 1, hp: 1000, dmg: 130, speed: 0.8, range: 90, atkSpd: 80, type: 'air', target: 'any', icon: 'ğŸ²', aoe: 50, radius: 16, mass: 4.0, deployTime: 60, rarity: 'epic' },
    fireball: { id: 'fireball', name: 'ç«çƒè¡“', cost: 4, count: 1, hp: 0, dmg: 350, speed: 0, range: 0, atkSpd: 0, type: 'spell', target: 'any', icon: 'ğŸ”¥', aoe: 110, knockback: 8, rarity: 'rare' },
    zap: { id: 'zap', name: 'é›»æ“Šæ³•è¡“', cost: 2, count: 1, hp: 0, dmg: 70, speed: 0, range: 0, atkSpd: 0, type: 'spell', target: 'any', icon: 'âš¡', aoe: 80, stun: 60, rarity: 'common' },
    goblins: { id: 'goblins', name: 'å“¥å¸ƒæ—', cost: 2, count: 3, hp: 180, dmg: 90, speed: 1.1, range: 0, atkSpd: 35, type: 'ground', target: 'any', icon: 'ğŸ‘º', radius: 10, mass: 0.8, deployTime: 10, rarity: 'common' },
    barrel: { id: 'barrel', name: 'å“¥å¸ƒæ—é£›æ¡¶', cost: 3, count: 1, hp: 0, dmg: 50, speed: 0, range: 0, atkSpd: 0, type: 'spell', target: 'any', icon: 'ğŸ›¢ï¸', spawnUnit: 'goblins', knockback: 0, rarity: 'epic' },
};
const DB = { cards: CARDS };

// ç©å®¶å­˜æª”
let Player = {
    name: "ç©å®¶1",
    gold: 150, gems: 20, trophies: 1000,
    deck: ['knight', 'archer', 'giant', 'fireball', 'musketeer', 'bats'],
    collection: Object.keys(CARDS).reduce((acc, k) => { acc[k] = { level: 1, shards: 0, maxShards: 50 }; return acc; }, {})
};

// --- ç²’å­èˆ‡ç‰©ç†ç³»çµ± ---
const AudioSys = {
    ctx: null,
    init() { window.AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); },
    play(type) {
        if(!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); gain.connect(this.ctx.destination); osc.connect(gain);
        if(type==='spawn'){ osc.frequency.setValueAtTime(300,t); osc.frequency.exponentialRampToValueAtTime(50,t+.2); gain.gain.setValueAtTime(.1,t); gain.gain.exponentialRampToValueAtTime(.01,t+.2); osc.start(); osc.stop(t+.2); }
        else if(type==='attack'){ osc.type='triangle'; osc.frequency.setValueAtTime(150,t); osc.frequency.linearRampToValueAtTime(100,t+.05); gain.gain.setValueAtTime(.05,t); gain.gain.linearRampToValueAtTime(0,t+.05); osc.start(); osc.stop(t+.05); }
        else if(type==='boom'){ osc.type='sawtooth'; osc.frequency.setValueAtTime(120,t); osc.frequency.exponentialRampToValueAtTime(10,t+.4); gain.gain.setValueAtTime(.2,t); gain.gain.exponentialRampToValueAtTime(.01,t+.4); osc.start(); osc.stop(t+.4); }
        else if(type==='ui'){ osc.frequency.setValueAtTime(800,t); gain.gain.setValueAtTime(.05,t); gain.gain.exponentialRampToValueAtTime(.01,t+.1); osc.start(); osc.stop(t+.1); }
    }
};
class Vector2 { constructor(x,y){this.x=x;this.y=y;} add(v){this.x+=v.x;this.y+=v.y;return this;} sub(v){this.x-=v.x;this.y-=v.y;return this;} mult(n){this.x*=n;this.y*=n;return this;} mag(){return Math.sqrt(this.x*this.x+this.y*this.y);} normalize(){let m=this.mag();if(m>0)this.mult(1/m);return this;} dist(v){return Math.hypot(this.x-v.x,this.y-v.y);} copy(){return new Vector2(this.x,this.y);}}
class ParticlePool { constructor(){this.pool=[];this.max=200;} get(x,y,c,t,v){let p=this.pool.find(i=>!i.active); if(!p){if(this.pool.length<this.max){p=new Particle();this.pool.push(p);}else return null;} p.reset(x,y,c,t,v); return p;} updateAndDraw(ctx){this.pool.forEach(p=>{if(p.active){p.update();p.draw(ctx);}});} clear(){this.pool.forEach(p=>p.active=false);} }
class Particle { constructor(){this.active=false;this.pos=new Vector2(0,0);this.vel=new Vector2(0,0);} reset(x,y,c,t,v){this.active=true;this.pos.x=x;this.pos.y=y;this.type=t;this.color=c;this.life=1.0; if(t==='text'||t==='emote'){this.text=v;this.vel=new Vector2(0,t==='emote'?-0.8:-2.5);this.scale=t==='emote'?1:Math.min(2,0.8+v/200);}else if(t==='spawn_flash'){this.vel=new Vector2(0,0);this.size=10;}else if(t==='water_ripple'){this.vel=new Vector2(0.5,0);this.size=Math.random()*5+2;}else{this.vel=new Vector2((Math.random()-0.5)*3,(Math.random()-0.5)*3);this.size=Math.random()*4+2;}} update(){this.pos.add(this.vel);this.life-=0.03;if(this.life<=0)this.active=false;if(this.type==='spawn_flash')this.size+=2;} draw(ctx){if(!this.active)return;ctx.globalAlpha=Math.max(0,this.life); if(this.type==='emote'){ctx.font="30px sans-serif";ctx.fillText(this.text,this.pos.x,this.pos.y);}else if(this.type==='spawn_flash'){ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,this.size,0,Math.PI*2);ctx.fill();}else if(this.type==='water_ripple'){ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,this.size,0,Math.PI*2);ctx.stroke();}else if(this.type==='text'){ctx.fillStyle=this.color;ctx.font="bold 16px sans-serif";ctx.fillText(this.text,this.pos.x,this.pos.y);}else{ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,this.size,0,Math.PI*2);ctx.fill();} ctx.globalAlpha=1;} }

// --- å¯¦é«”é¡åˆ¥ (Entities) ---
class Entity {
    constructor(x, y, team, radius) { this.pos=new Vector2(x,y); this.team=team; this.radius=radius; this.dead=false; this.hp=100; this.maxHp=100; this.flash=0; this.shakeX=0; this.shakeY=0; this.knockbackVel=new Vector2(0,0); this.stunTimer=0; }
    takeDamage(amt, isCrit=false) {
        this.hp-=amt; this.flash=5; this.shakeX=(Math.random()-0.5)*6; this.shakeY=(Math.random()-0.5)*6;
        Game.particles.get(this.pos.x, this.pos.y-30, '#fff', isCrit?'crit':'text', Math.floor(amt)+(isCrit?"!":""));
        if(this.hp<=0) { this.dead=true; if(this.deathDmg) Game.projectiles.push(new Projectile(this.pos, new Vector2(0,0), this.deathDmg, 100, 'explosion', this.team)); for(let i=0;i<3;i++) Game.particles.get(this.pos.x,this.pos.y,'#a55eea','soul',0); }
    }
    drawHp(ctx, offset) {
        if(this.hp<this.maxHp && this.hp>0) {
            const w=32; ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(this.pos.x-w/2-2+this.shakeX, this.pos.y-this.radius-offset-2+this.shakeY, w+4, 8);
            ctx.fillStyle=this.team==='player'?CONFIG.COLORS.P_MAIN:CONFIG.COLORS.E_MAIN; ctx.fillRect(this.pos.x-w/2+this.shakeX, this.pos.y-this.radius-offset+this.shakeY, w*(this.hp/this.maxHp), 4);
        }
    }
    drawShadow(ctx) {
        ctx.fillStyle = this.type==='air' ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+(this.type==='air'?40:0), this.radius, this.radius*0.6, 0, 0, Math.PI*2); ctx.fill();
    }
}

class Unit extends Entity {
    constructor(x, y, team, key) {
        const d = CARDS[key]; super(x, y, team, d.radius);
        this.key=key; this.hp=d.hp; this.maxHp=d.hp; this.dmg=d.dmg; this.speed=d.speed; this.range=d.range; this.atkSpd=d.atkSpd; this.type=d.type||'ground'; this.targetType=d.target; this.mass=d.mass;
        this.deployTimer=d.deployTime; this.maxDeploy=d.deployTime; this.atkTimer=0; this.facing=1; this.frame=Math.random()*100;
        this.chargeSpeed=d.chargeSpeed||0; this.chargeDmgMult=d.chargeDmgMult||1; this.isCharging=false; this.moveTime=0;
    }
    update() {
        if(this.dead) return;
        this.shakeX*=0.8; this.shakeY*=0.8;
        if(this.knockbackVel.mag()>0.1) { this.pos.add(this.knockbackVel); this.knockbackVel.mult(0.85); this.collide(); return; }
        if(this.deployTimer>0) { this.deployTimer--; return; }
        if(this.stunTimer>0) { this.stunTimer--; return; }
        this.frame++; if(this.flash>0) this.flash--; if(this.atkTimer>0) this.atkTimer--;
        
        const target = this.findTarget();
        if(target) {
            const dist = this.pos.dist(target.pos);
            if(dist <= this.range + this.radius + target.radius) {
                this.state='attack';
                if(this.atkTimer <= 0) this.attack(target);
                this.moveTime=0; this.isCharging=false;
            } else if(this.speed > 0) {
                this.state='move'; this.moveTowards(target.pos); this.moveTime++;
                if(this.chargeSpeed>0 && this.moveTime>120) this.isCharging=true;
            }
        } else if(this.speed > 0) {
            this.state='move'; const goalY = this.team==='player' ? -100 : Game.height+100;
            this.moveTowards(new Vector2(this.pos.x, goalY)); this.moveTime++;
        }
        if(this.speed>0) this.collide();
    }
    moveTowards(dest) {
        let target = dest.copy();
        const riverY = Game.height * CONFIG.RIVER_OFFSET;
        // æ©‹æ¨‘å°‹è·¯é‚è¼¯
        if(this.type!=='air' && ((this.pos.y<riverY && dest.y>riverY) || (this.pos.y>riverY && dest.y<riverY)) && Math.abs(this.pos.y-riverY)>20) {
            const bL = Game.width*0.25, bR = Game.width*0.75;
            const bridgeX = Math.abs(this.pos.x-bL)<Math.abs(this.pos.x-bR) ? bL : bR;
            target = new Vector2(bridgeX + (this.pos.x%30-15), riverY);
        }
        let spd = this.isCharging ? this.chargeSpeed : this.speed;
        const dir = target.sub(this.pos).normalize();
        this.pos.add(dir.mult(spd));
        if(dir.x>0.1) this.facing=1; else if(dir.x<-0.1) this.facing=-1;
    }
    collide() {
        if(this.type==='air') return;
        const force = new Vector2(0,0);
        Game.units.forEach(u => {
            if(u===this || u.dead || u.deployTimer>0 || u.type==='air') return;
            const d = this.pos.dist(u.pos), minD = this.radius+u.radius;
            if(d<minD) force.add(this.pos.copy().sub(u.pos).normalize().mult((minD-d)*0.15 * Math.min(2, u.mass/this.mass)));
        });
        this.pos.add(force);
        this.pos.x = Math.max(15, Math.min(Game.width-15, this.pos.x));
    }
    findTarget() {
        const list = this.targetType==='building' ? [...Game.towers, ...Game.units.filter(u=>u.type==='building')] : [...Game.towers, ...Game.units];
        let best = null, minD = Infinity;
        list.forEach(t => {
            // åš´æ ¼æª¢æŸ¥éšŠä¼ï¼Œé¿å…æ‰“è‡ªå·±äºº
            if(t.team!==this.team && !t.dead && t.deployTimer<=0) {
                if(t instanceof Tower && t.isKing && !t.active && t.team!==this.team) return;
                const d = this.pos.dist(t.pos); if(d<minD) { minD=d; best=t; }
            }
        });
        if(!best && this.targetType!=='building') best = Game.towers.find(t=>t.team!==this.team && t.isKing);
        return best;
    }
    attack(target) {
        const dmg = this.isCharging ? this.dmg * this.chargeDmgMult : this.dmg;
        if(this.range>50) Game.projectiles.push(new Projectile(this.pos, target, dmg, this.aoe, this.key, this.team));
        else {
            const isCrit = (this.key==='minipekka' || this.isCharging);
            target.takeDamage(dmg, isCrit);
            AudioSys.play(this.isCharging?'charge_hit':(isCrit?'heavy_hit':'attack'));
            Game.particles.get((this.pos.x+target.pos.x)/2, (this.pos.y+target.pos.y)/2, '#fff', 'spark', 0);
        }
        this.atkTimer = this.atkSpd;
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.pos.x+this.shakeX, this.pos.y+this.shakeY); if(this.type==='air') ctx.translate(0,-40);
        if(this.deployTimer>0) {
            ctx.globalAlpha=0.6; ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(0,0,this.radius+5,0,Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(0,0); ctx.fillStyle='#ecf0f1'; ctx.arc(0,0,this.radius+5,-Math.PI/2,-Math.PI/2+(Math.PI*2*(1-this.deployTimer/this.maxDeploy))); ctx.lineTo(0,0); ctx.fill(); ctx.restore(); return;
        }
        if(this.flash>0) ctx.filter='brightness(3)';
        
        const col = this.team==='player' ? CONFIG.COLORS.P_MAIN : CONFIG.COLORS.E_MAIN;
        const bob = Math.sin(this.frame*0.2)*2;
        ctx.translate(0, -bob); ctx.scale(this.facing, 1);

        // --- V1 ç‰¹æ•ˆç¹ªè£½ ---
        if (this.key === 'giant') {
            ctx.fillStyle = '#d35400'; ctx.fillRect(-14, -28, 28, 28);
            ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.arc(0, -34, 12, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = col; ctx.fillRect(-14,-22,28,12);
        } else if (this.key === 'knight') {
            ctx.fillStyle = col; ctx.beginPath(); ctx.arc(0, -8, 12, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
            ctx.save(); ctx.translate(10, -5);
            const swing = this.state === 'attack' ? Math.sin(this.frame*0.6)*1.5 : -0.5;
            ctx.rotate(swing);
            ctx.fillStyle = '#bdc3c7'; ctx.fillRect(0, -12, 4, 24); ctx.fillRect(-3, 8, 10, 3);
            ctx.restore();
        } else if (this.key === 'archer') {
            ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(-8,-5); ctx.lineTo(8,-5); ctx.fill();
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(0, -5, 6, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#8e44ad'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(8, 0, 8, -Math.PI/2, Math.PI/2); ctx.stroke();
        } else if (this.key === 'prince') {
            ctx.fillStyle = col; ctx.fillRect(-8, -15, 16, 15);
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(0, -22, 8, 0, Math.PI*2); ctx.fill();
            ctx.save(); ctx.translate(8, -10);
            const angle = this.state === 'move' ? Math.PI/4 : 0;
            ctx.rotate(angle);
            ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(25, -2); ctx.lineTo(25, 2); ctx.fill();
            if (this.isCharging) { ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.fillRect(0,-1,30,2); }
            ctx.restore();
        } else if (this.key === 'minipekka') {
            ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-10,-20,20,20);
            ctx.fillStyle = col; ctx.fillRect(-10,-15,20,5);
            ctx.fillStyle = '#00ffff'; ctx.shadowBlur=5; ctx.shadowColor='#00ffff';
            ctx.beginPath(); ctx.arc(0,-12,4,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
            ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.moveTo(-10,-20); ctx.lineTo(-14,-28); ctx.lineTo(-6,-20); ctx.fill(); ctx.beginPath(); ctx.moveTo(10,-20); ctx.lineTo(14,-28); ctx.lineTo(6,-20); ctx.fill();
        } else if (this.key === 'hogrider') {
            ctx.fillStyle = '#8d6e63'; ctx.beginPath(); ctx.arc(0, -20, 8, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, -20, 8, Math.PI, 0); ctx.fill();
            ctx.fillStyle = '#ff7675'; ctx.fillRect(-10, -15, 20, 15);
            ctx.fillStyle = '#634200'; ctx.beginPath(); ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#dfe6e9'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(10,-15); ctx.lineTo(10,-25); ctx.stroke();
        } else if (this.key === 'babydragon') {
            ctx.fillStyle = '#00b894'; ctx.beginPath(); ctx.ellipse(0, 0, 12, 10, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fdcb6e'; ctx.beginPath(); ctx.moveTo(-5, -5); ctx.lineTo(-15, -15); ctx.lineTo(-5, 5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(5, -5); ctx.lineTo(15, -15); ctx.lineTo(5, 5); ctx.fill();
            ctx.fillStyle = '#00b894'; ctx.beginPath(); ctx.arc(0, -12, 8, 0, Math.PI*2); ctx.fill();
        } else if (this.key === 'musketeer') {
            ctx.fillStyle = '#9b59b6'; ctx.fillRect(-6, -18, 12, 18);
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(0, -20, 8, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#333'; ctx.fillRect(6, -14, 14, 4);
        } else if (this.key === 'bats') {
            ctx.fillStyle = '#6c5ce7'; ctx.beginPath(); ctx.arc(0, -5, 6, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#2d3436'; ctx.beginPath(); ctx.moveTo(-5,-5); ctx.lineTo(-12,-12); ctx.lineTo(-5,0); ctx.fill();
            ctx.beginPath(); ctx.moveTo(5,-5); ctx.lineTo(12,-12); ctx.lineTo(5,0); ctx.fill();
        } else if (this.key === 'goblins') {
            ctx.fillStyle = '#55efc4'; ctx.beginPath(); ctx.arc(0,-5,8,0,Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-6,-10); ctx.lineTo(-12,-18); ctx.lineTo(0,-10); ctx.fill();
            ctx.beginPath(); ctx.moveTo(6,-10); ctx.lineTo(12,-18); ctx.lineTo(0,-10); ctx.fill();
        } else {
            ctx.fillStyle = (this.key==='skarmy'?'#fff':col);
            ctx.beginPath(); ctx.arc(0, -5, this.radius-2, 0, Math.PI*2); ctx.fill();
        }

        ctx.restore(); this.drawHp(ctx, this.radius+(this.type==='air'?45:5));
    }
}

class Tower extends Entity {
    constructor(x, y, team, isKing) {
        super(x, y, team, isKing?32:24);
        this.isKing = isKing; this.active = !isKing;
        this.maxHp = isKing?4000:2500; this.hp = this.maxHp; this.range = 160; this.atkTimer = 0;
        this.name = ""; 
    }
    update() {
        this.shakeX*=0.8; this.shakeY*=0.8; if(this.flash>0) this.flash--;
        if(this.isKing && !this.active) { if(this.hp<this.maxHp || Game.towers.some(t=>t.team===this.team && !t.isKing && t.dead)) this.active=true; }
        if(!this.active) return;
        if(this.atkTimer>0) this.atkTimer--;
        let target = null, minD = this.range;
        // å¡”åªæ‰“æ•µäºº
        Game.units.forEach(u => { if(u.team!==this.team && !u.dead && u.deployTimer<=0) { const d=this.pos.dist(u.pos); if(d<minD){minD=d; target=u;} } });
        if(target && this.atkTimer<=0) {
            Game.projectiles.push(new Projectile(new Vector2(this.pos.x, this.pos.y-(this.isKing?40:30)), target, this.isKing?120:90, 0, 'arrow', this.team));
            this.atkTimer = 45;
        }
    }
    draw(ctx) {
        const x = this.pos.x + this.shakeX, y = this.pos.y + this.shakeY;
        const col = this.team === 'player' ? CONFIG.COLORS.P_MAIN : CONFIG.COLORS.E_MAIN;
        
        ctx.save(); if(this.flash>0) ctx.translate((Math.random()-0.5)*4, (Math.random()-0.5)*4);
        
        ctx.fillStyle = '#95a5a6'; const w = this.radius * 1.8; const h = this.isKing ? 40 : 30;
        ctx.fillRect(x - w/2, y - 10, w, 20);
        ctx.fillStyle = '#bdc3c7'; ctx.fillRect(x - w/2 + 4, y - 10 - h, w - 8, h);
        ctx.fillStyle = col; ctx.fillRect(x - w/2 + 4, y - 10 - h + 5, w - 8, 6);
        
        const topY = y - 10 - h;
        if(this.isKing) {
            if(this.active) {
                ctx.fillStyle = col; ctx.beginPath(); ctx.moveTo(x - w/2 - 2, topY - 6); ctx.lineTo(x + w/2 + 2, topY - 6); ctx.lineTo(x, topY - 30); ctx.fill();
                ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x, topY-30); ctx.lineTo(x, topY-45); ctx.stroke();
            } else {
                ctx.fillStyle = col; ctx.fillRect(x - 15, topY - 20, 30, 20);
                ctx.font = "20px sans-serif"; ctx.textAlign="center"; ctx.fillText("ğŸ’¤", x, topY - 25 + (Math.sin(Date.now()/300)*5));
            }
        } else {
            ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.moveTo(x - w/2, topY - 6); ctx.lineTo(x + w/2, topY - 6); ctx.lineTo(x, topY - 20); ctx.fill();
        }
        ctx.restore(); this.drawHp(ctx, this.isKing?65:45);
    }
}

class Projectile {
    constructor(pos, target, dmg, aoe, key, team) {
        this.pos = pos.copy(); this.startPos = pos.copy(); this.target = target; this.dmg = dmg; this.aoe = aoe; this.key = key; this.team = team;
        this.isSpell = (key==='fireball'||key==='barrel'||key==='zap');
        this.dest = this.isSpell ? target.copy() : target.pos.copy();
        this.speed = key==='barrel'?Math.max(3,this.pos.dist(this.dest)/60) : (key==='fireball'?6:7);
        this.height = 0; this.dead = false; this.tail=[];
    }
    update() {
        if(!this.isSpell && !this.target.dead) this.dest = this.target.pos.copy();
        const dToT = this.pos.dist(this.dest), travelled = this.pos.dist(this.startPos);
        if(this.isSpell) this.height = Math.sin((travelled/(travelled+dToT))*Math.PI) * 120; // æ‹‹ç‰©ç·š
        
        if(dToT < this.speed+5 && this.height<15) {
            this.dead = true;
            if(this.key==='barrel') { for(let i=0;i<3;i++) Game.units.push(new Unit(this.dest.x+(i-1)*10, this.dest.y, this.team, 'goblins')); AudioSys.play('boom'); return; }
            let targets = (this.aoe>0 || this.isSpell) ? [...Game.units, ...Game.towers].filter(e=>e.pos.dist(this.dest)<=this.aoe) : [this.target];
            if(this.aoe>0) AudioSys.play(this.key==='zap'?'zap':'boom');
            targets.forEach(t => { if(t.team!==this.team){ t.takeDamage(this.dmg); if(this.key==='fireball') t.knockbackVel.add(t.pos.copy().sub(this.pos).normalize().mult(8)); } });
        } else {
            this.pos.add(this.dest.copy().sub(this.pos).normalize().mult(this.speed));
        }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.pos.x, this.pos.y-this.height);
        if(this.key === 'arrow') {
            const angle = Math.atan2(this.dest.y - this.pos.y, this.dest.x - this.pos.x);
            ctx.rotate(angle);
            ctx.fillStyle = '#bdc3c7'; ctx.fillRect(-10, -1, 20, 2);
            ctx.fillStyle = '#ecf0f1'; ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-15, -3); ctx.lineTo(-15, 3); ctx.fill();
            ctx.fillStyle = (this.team === 'player' ? CONFIG.COLORS.P_MAIN : CONFIG.COLORS.E_MAIN); ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(5, -3); ctx.lineTo(5, 3); ctx.fill();
        } else {
            ctx.fillStyle = this.team==='player'?CONFIG.COLORS.P_MAIN:CONFIG.COLORS.E_MAIN;
            if(this.key==='fireball') ctx.fillStyle='#e74c3c';
            ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

// --- Lobby Logic (å¤§å»³é‚è¼¯) ---
const Lobby = {
    init() {
        this.renderResources();
        this.renderDeck();
        this.updateRank();
    },
    renderResources() {
        document.getElementById('ui-gold').innerText = Player.gold;
        document.getElementById('ui-gem').innerText = Player.gems;
        document.getElementById('ui-trophy').innerText = Player.trophies;
    },
    updateRank() {
        const arenas = ["è¨“ç·´ç‡Ÿ", "å“¥å¸ƒæ—ç«¶æŠ€å ´", "ç™½éª¨å‘", "é‡è »äººæ“‚å°"];
        const idx = Math.min(Math.floor(Player.trophies / 400), arenas.length-1);
        document.getElementById('arena-name').innerText = arenas[idx];
    },
    switchTab(tabName, btn) {
        document.querySelectorAll('.tab-pane').forEach(el => el.classList.remove('active'));
        document.getElementById(`tab-${tabName}`).classList.add('active');
        document.querySelectorAll('.nav-btn').forEach(el => el.classList.remove('active'));
        if(btn) btn.classList.add('active');
    },
    switchSocial(mode) {
        document.querySelectorAll('.tab-pill').forEach(el => el.classList.remove('active'));
        event.target.classList.add('active');
        document.getElementById('view-friends').classList.toggle('hidden', mode !== 'friends');
        document.getElementById('view-clan').classList.toggle('hidden', mode !== 'clan');
    },
    renderDeck() {
        const grid = document.getElementById('deck-grid');
        grid.innerHTML = '';
        Object.keys(Player.collection).forEach(key => {
            const card = DB.cards[key];
            const data = Player.collection[key];
            const el = document.createElement('div');
            const equipped = Player.deck.includes(key) ? 'equipped' : '';
            const canUpgrade = data.shards >= data.maxShards && Player.gold >= 50;
            const arrow = canUpgrade ? `<div class="upgrade-arrow">â¬†</div>` : '';
            el.className = `deck-card card ${card.rarity} ${equipped}`;
            el.innerHTML = `${arrow}<div class="cost">${card.cost}</div><div class="card-inner"><div class="emoji">${card.icon}</div></div><div class="lv-badge">Lv.${data.level}</div>`;
            el.onclick = () => this.selectCardForUpgrade(key);
            grid.appendChild(el);
        });
    },
    selectCardForUpgrade(key) {
        const card = DB.cards[key];
        const data = Player.collection[key];
        const panel = document.getElementById('upgrade-panel');
        const btn = document.getElementById('btn-upgrade');
        panel.classList.add('active');
        document.getElementById('upg-icon').innerText = card.icon;
        document.getElementById('upg-name').innerText = card.name;
        document.getElementById('upg-level').innerText = `ç­‰ç´š ${data.level}`;
        document.getElementById('upg-count').innerText = `${data.shards}/${data.maxShards}`;
        const pct = Math.min(100, (data.shards / data.maxShards) * 100);
        document.getElementById('upg-bar').style.width = `${pct}%`;
        if (data.shards >= data.maxShards && Player.gold >= 50) {
            btn.style.background = '#2ecc71'; btn.disabled = false;
            btn.onclick = () => {
                Player.gold -= 50; data.level++; data.shards -= data.maxShards; data.maxShards += 10;
                alert(`å‡ç´šæˆåŠŸï¼${card.name} Lv.${data.level}`);
                this.init(); this.selectCardForUpgrade(key);
            };
        } else {
            btn.style.background = '#95a5a6'; btn.disabled = true;
        }
    },
    openChest(el) {
        if(!el.classList.contains('has-loot')) return;
        el.classList.remove('has-loot'); el.innerText = "é–‹å•Ÿä¸­...";
        setTimeout(() => {
            const gold = Math.floor(Math.random()*50)+20;
            const gems = Math.floor(Math.random()*3);
            Player.gold += gold; Player.gems += gems;
            const cardKey = Object.keys(Player.collection)[Math.floor(Math.random()*Object.keys(Player.collection).length)];
            Player.collection[cardKey].shards += 5;
            alert(`ç²å¾—ï¼š\nğŸ’° ${gold} é‡‘å¹£\nğŸ’ ${gems} å¯¶çŸ³\nğŸƒ ${DB.cards[cardKey].name} x5`);
            el.innerText = "ç©ºä½";
            this.init();
        }, 1000);
    },
    findMatch() {
        document.getElementById('btn-find-match').disabled = true;
        document.getElementById('btn-find-match').innerText = "å°‹æ‰¾ä¸­...";
        Game.startMatchmaking();
    }
};

// --- Game Logic (æˆ°é¬¥é‚è¼¯) ---
const Game = {
    canvas: null, ctx: null, width: 0, height: 0, running: false,
    units: [], towers: [], projectiles: [], particles: new ParticlePool(),
    elixir: 5, hand: [], nextCard: null, 
    socket: null, roomID: null, 
    selectedIdx: null, draggingIdx: null, dragPos: {x:0,y:0}, isDragging: false,

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        const container = document.getElementById('game-container');
        container.onpointerdown = e => this.pDown(e);
        container.onpointermove = e => this.pMove(e);
        container.onpointerup = e => this.pUp(e);
        AudioSys.init();
        Lobby.init();
    },

    activateGameView() {
        document.getElementById('lobby-layer').style.display = 'none';
        const container = document.getElementById('game-container');
        container.classList.add('active'); 
        setTimeout(() => { this.resize(); this.canvas.width = this.width; this.canvas.height = this.height; }, 50);
        window.addEventListener('resize', () => this.resize());
    },

    resize(){ const w=document.getElementById('canvas-wrapper'); if(w){this.width=w.clientWidth; this.height=w.clientHeight; this.canvas.width=this.width; this.canvas.height=this.height;} },

    startMatchmaking() {
        if(!this.socket) this.socket = io();
        this.socket.emit('find_match', { trophies: Player.trophies });
        this.socket.on('game_start', (data) => {
            this.roomID = data.roomID;
            this.showMessage("é…å°æˆåŠŸï¼");
            document.getElementById('enemy-name-txt').innerText = "æŒ‘æˆ°è€…";
            setTimeout(() => this.startGame(), 1000);
        });
        this.socket.on('no_match_found', () => {
            this.roomID = 'local_bot';
            this.showMessage("è¨“ç·´å¸«ä¾†è¥²ï¼");
            document.getElementById('enemy-name-txt').innerText = "è¨“ç·´å¸« AI";
            setTimeout(() => this.startGame(), 1000);
        });
        this.socket.on('remote_action', (data) => {
            if(data.type === 'spawn') {
                // é¡åƒè½‰æ›
                const realX = (1 - data.nx) * this.width;
                const realY = (1 - data.ny) * this.height;
                // é—œéµä¿®å¾©ï¼šè¨­ç½® fromRemote ç‚º true
                this.spawn(data.card, realX, realY, 'enemy', true);
            } else if (data.type === 'emote') {
                this.showEmote(data.val, 'enemy');
            }
        });
    },

    startGame() {
        this.activateGameView();
        this.running = true;
        this.elixir = 5;
        this.units = []; this.projectiles = []; this.particles.clear();
        
        // å‹•æ…‹ç”Ÿæˆå¡”çš„ä½ç½®ï¼Œé˜²æ­¢è·‘ç‰ˆ
        const pY = this.height - 120, eY = 120;
        const bL = this.width * 0.25, bR = this.width * 0.75;
        this.towers = [
            new Tower(bL, pY, 'player', false), new Tower(bR, pY, 'player', false), new Tower(this.width/2, pY+40, 'player', true),
            new Tower(bL, eY, 'enemy', false), new Tower(bR, eY, 'enemy', false), new Tower(this.width/2, eY-40, 'enemy', true)
        ];

        let deck = [...Player.deck, ...Player.deck].sort(()=>Math.random()-0.5);
        this.hand = deck.slice(0,4);
        this.nextCard = deck[4];
        this.renderDeck();

        let timeLeft = CONFIG.GAME_TIME;
        const timerEl = document.getElementById('timer');
        this.timerInt = setInterval(() => {
            if(!this.running) return;
            timeLeft--;
            const m = Math.floor(timeLeft/60), s = timeLeft%60;
            timerEl.innerText = `0${m}:${s<10?'0'+s:s}`;
            if(timeLeft===CONFIG.DOUBLE_ELIXIR_THRESHOLD) {
                document.getElementById('elixir-mode-txt').className='show';
                setTimeout(()=>document.getElementById('elixir-mode-txt').className='',2000);
            }
            if(timeLeft <= 0) this.endGame(null);
        }, 1000);

        if(this.roomID === 'local_bot') {
            setInterval(() => {
                if(!this.running) return;
                const cards = ['knight','archer','giant'];
                const k = cards[Math.floor(Math.random()*cards.length)];
                const x = Math.random()>0.5 ? bL : bR;
                this.spawn(k, x, 80, 'enemy', true);
            }, 4000);
        }
        this.loop();
    },

    loop() {
        if(!this.running) return;
        requestAnimationFrame(() => this.loop());
        this.elixir = Math.min(CONFIG.ELIXIR_MAX, this.elixir + CONFIG.ELIXIR_RATE_BASE);
        this.renderElixir();
        if(Math.random()<0.05) Game.particles.get(Math.random()*this.width, this.height*0.5+(Math.random()-0.5)*20, null, 'water_ripple', 0);
        [...this.units, ...this.towers, ...this.projectiles].forEach(e => e.update());
        this.particles.updateAndDraw(this.ctx);
        this.units = this.units.filter(u => !u.dead);
        this.projectiles = this.projectiles.filter(p => !p.dead);
        this.towers = this.towers.filter(t => !t.dead);
        const pK = this.towers.find(t=>t.team==='player'&&t.isKing);
        const eK = this.towers.find(t=>t.team==='enemy'&&t.isKing);
        if(!pK) this.endGame(false); else if(!eK) this.endGame(true);
        this.draw();
    },

    draw() {
        const ctx = this.ctx;
        if(this.width === 0) return;
        ctx.clearRect(0,0,this.width,this.height);
        ctx.fillStyle = CONFIG.COLORS.GRASS; ctx.fillRect(0,0,this.width,this.height);
        ctx.fillStyle = 'rgba(0,0,0,0.03)'; const size = 40;
        for(let x=0; x<this.width; x+=size) for(let y=0; y<this.height; y+=size) if((x/size + y/size)%2===0) ctx.fillRect(x, y, size, size);
        const ry = this.height*CONFIG.RIVER_OFFSET;
        ctx.fillStyle = CONFIG.COLORS.WATER; ctx.fillRect(0, ry-30, this.width, 60);
        ctx.fillStyle = 'rgba(255,255,255,0.2)'; const t = Date.now()/500;
        for(let y=ry-25; y<ry+25; y+=8) { const s = Math.sin(y*0.1 + t)*10; ctx.fillRect(0, y, this.width, 2); }
        const drawBridge = (bx) => {
            ctx.fillStyle = '#636e72'; ctx.fillRect(bx-30, ry-35, 60, 70);
            ctx.fillStyle = '#b2bec3'; ctx.fillRect(bx-26, ry-35, 52, 70);
            ctx.fillStyle = '#dfe6e9'; for(let i=0; i<6; i++) ctx.fillRect(bx-24, ry-30 + i*11, 48, 4);
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(bx-26, ry+35, 52, 5);
        };
        drawBridge(this.width*0.25); drawBridge(this.width*0.75);
        this.units.forEach(u=>u.drawShadow(ctx)); this.towers.forEach(t=>t.drawShadow(ctx));
        [...this.towers, ...this.units].sort((a,b)=>a.pos.y-b.pos.y).forEach(e=>e.draw(ctx));
        this.projectiles.forEach(p=>p.draw(ctx));
        if(this.isDragging) {
            const d = CARDS[this.hand[this.draggingIdx]];
            const valid = d.type==='spell' || this.dragPos.y > this.height*CONFIG.RIVER_OFFSET;
            ctx.save(); ctx.translate(this.dragPos.x, this.dragPos.y);
            ctx.globalAlpha=0.5; ctx.fillStyle=valid?'#3498db':'#e74c3c';
            ctx.beginPath(); ctx.arc(0,0,d.radius||d.aoe||20,0,Math.PI*2); ctx.fill();
            ctx.font="30px serif"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(d.icon,0,0);
            ctx.restore();
        }
    },

    pDown(e) {
        if(!this.running) return;
        const t = e.target.closest('.card');
        const rect = this.canvas.getBoundingClientRect();
        if(t && t.dataset.index) {
            const idx = parseInt(t.dataset.index);
            if(this.elixir >= CARDS[this.hand[idx]].cost) {
                this.draggingIdx = idx; this.selectedIdx = idx; this.isDragging = true;
                this.dragPos = {x: e.clientX-rect.left, y: e.clientY-rect.top};
                this.renderDeck();
            }
        } else if (this.selectedIdx !== null && !this.isDragging) {
            const y = e.clientY - rect.top;
            if(y < this.height) this.trySpawn(this.selectedIdx, e.clientX-rect.left, y);
        }
    },
    pMove(e) { 
        const rect = this.canvas.getBoundingClientRect();
        if(this.isDragging) this.dragPos = {x: e.clientX-rect.left, y: e.clientY-rect.top};
    },
    pUp(e) {
        if(this.isDragging) {
            const rect = this.canvas.getBoundingClientRect();
            if(e.clientY-rect.top < this.height-100) this.trySpawn(this.draggingIdx, this.dragPos.x, this.dragPos.y);
            this.isDragging=false; this.draggingIdx=null; this.selectedIdx=null; this.renderDeck();
        }
    },
    
    trySpawn(idx, x, y) {
        const key = this.hand[idx];
        const d = CARDS[key];
        const riverY = this.height * CONFIG.RIVER_OFFSET;
        if(d.type!=='spell' && y < riverY) { this.showMessage("åƒ…èƒ½éƒ¨ç½²æ–¼å·±æ–¹å€åŸŸ"); return; }
        this.elixir -= d.cost;
        this.spawn(key, x, y, 'player');
        if(this.socket && this.roomID !== 'local_bot') {
            this.socket.emit('action', {
                roomID: this.roomID, type: 'spawn', card: key,
                nx: x / this.width, ny: y / this.height
            });
        }
        this.hand[idx] = this.nextCard;
        this.nextCard = Player.deck[Math.floor(Math.random()*Player.deck.length)];
        this.renderDeck();
    },

    spawn(key, x, y, team, fromRemote=false) {
        const d = CARDS[key];
        AudioSys.play('spawn');
        if(d.type==='spell') {
            // fromRemote æ™‚ï¼Œæ³•è¡“æ˜¯å¾é ‚éƒ¨é£›éä¾†çš„
            this.projectiles.push(new Projectile(new Vector2(fromRemote?x:this.width/2, fromRemote?0:this.height), new Vector2(x,y), d.dmg, d.aoe, key, team));
        } else {
            const count = d.count || 1;
            for(let i=0; i<count; i++) {
                let ox = (i-(count-1)/2)*15; 
                this.units.push(new Unit(x+ox, y, team, key));
            }
            Game.particles.get(x, y, '#fff', 'spawn_flash', 0);
        }
    },

    triggerEmote(emoji) {
        this.showEmote(emoji, 'player');
        if(this.socket && this.roomID !== 'local_bot') this.socket.emit('action', { roomID: this.roomID, type: 'emote', val: emoji });
        document.getElementById('emote-menu').classList.remove('open');
    },
    showEmote(emoji, team) {
        const t = this.towers.find(t => t.team === team && t.isKing);
        if(t) Game.particles.get(t.pos.x, t.pos.y-60, null, 'emote', emoji);
    },

    renderElixir() {
        document.getElementById('elixir-fill').style.width = (this.elixir*10)+'%';
        document.getElementById('elixir-badge').innerText = Math.floor(this.elixir);
        document.querySelectorAll('#hand-cards .card').forEach((el,i)=>{
            if(this.hand[i]) el.classList.toggle('disabled', this.elixir < CARDS[this.hand[i]].cost);
        });
    },
    renderDeck() {
        document.getElementById('next-icon').innerText = CARDS[this.nextCard].icon;
        const h = document.getElementById('hand-cards'); h.innerHTML='';
        this.hand.forEach((k,i)=>{
            const d=CARDS[k], el=document.createElement('div');
            el.className=`card ${d.rarity}`; el.dataset.index=i;
            if(this.selectedIdx===i && !this.isDragging) el.classList.add('selected');
            if(this.draggingIdx===i) el.classList.add('dragging');
            el.innerHTML=`<div class="cost">${d.cost}</div><div class="card-inner"><div class="emoji">${d.icon}</div></div>`;
            h.appendChild(el);
        });
        this.renderElixir();
    },
    showMessage(msg) {
        const m = document.getElementById('message'); m.innerText = msg; m.classList.add('show');
        setTimeout(()=>m.classList.remove('show'), 1500);
    },
    endGame(win) {
        this.running = false; clearInterval(this.timerInt);
        document.getElementById('end-screen').classList.remove('hidden');
        document.getElementById('end-screen').classList.add('active');
        const title = document.getElementById('end-title');
        if(win) {
            title.innerText = "å‹åˆ©!"; title.style.color = "#f1c40f";
            Player.trophies += 30; Player.gold += 50;
        } else {
            title.innerText = "å¤±æ•—"; title.style.color = "#e74c3c";
            Player.trophies = Math.max(0, Player.trophies - 20); Player.gold += 10;
        }
    }
};

window.onload = () => Game.init();
</script>
</body>
</html>